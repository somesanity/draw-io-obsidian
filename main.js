/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DrawIOPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var import_child_process = require("child_process");
var DRAWIO_VIEW = "drawio-webview";
var DrawIOPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.serveProcess = null;
  }
  async onload() {
    this.registerView(DRAWIO_VIEW, (leaf) => new DrawIOView(leaf, this));
    this.addRibbonIcon("shapes", "open Draw.io", async () => {
      await this.launchDrawioServer();
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.setViewState({
        type: DRAWIO_VIEW,
        active: true
      });
    });
    new import_obsidian.Notice("\u2705 Draw.io is loaded!");
  }
  onunload() {
    if (this.serveProcess) {
      this.serveProcess.kill("SIGTERM");
      this.serveProcess = null;
      new import_obsidian.Notice("\u{1F6D1} Server Draw.io is stopped.");
    }
    this.app.workspace.detachLeavesOfType(DRAWIO_VIEW);
  }
  async launchDrawioServer() {
    if (this.serveProcess)
      return;
    const vaultBasePath = this.app.vault.adapter.basePath;
    const pluginDir = path.join(vaultBasePath, this.manifest.dir);
    const webAppPath = path.join(pluginDir, "webapp");
    if (!fs.existsSync(webAppPath)) {
      new import_obsidian.Notice("\u{1F4C2} folder 'webapp' not found.");
      return;
    }
    this.serveProcess = (0, import_child_process.spawn)("npx", ["serve", webAppPath, "-l", "8080"], {
      cwd: pluginDir,
      shell: true,
      detached: false
    });
    await new Promise((res) => setTimeout(res, 1e3));
  }
};
var DrawIOView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return DRAWIO_VIEW;
  }
  getDisplayText() {
    return "Draw.io";
  }
  getIcon() {
    return "shapes";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const iframe = container.createEl("iframe", {
      attr: {
        src: "http://localhost:8080",
        style: "width: 100%; height: 100%; border: none;"
      }
    });
  }
  async onClose() {
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCBXb3Jrc3BhY2VMZWFmLCBJdGVtVmlldywgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IHNwYXduLCBDaGlsZFByb2Nlc3NXaXRob3V0TnVsbFN0cmVhbXMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuXG5jb25zdCBEUkFXSU9fVklFVyA9IFwiZHJhd2lvLXdlYnZpZXdcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhd0lPUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBwcml2YXRlIHNlcnZlUHJvY2VzczogQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zIHwgbnVsbCA9IG51bGw7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KERSQVdJT19WSUVXLCAobGVhZikgPT4gbmV3IERyYXdJT1ZpZXcobGVhZiwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbihcInNoYXBlc1wiLCBcIm9wZW4gRHJhdy5pb1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxhdW5jaERyYXdpb1NlcnZlcigpO1xuXG4gICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYodHJ1ZSk7XG4gICAgICAgICAgICBhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogRFJBV0lPX1ZJRVcsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBOb3RpY2UoXCJcdTI3MDUgRHJhdy5pbyBpcyBsb2FkZWQhXCIpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZVByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVQcm9jZXNzLmtpbGwoXCJTSUdURVJNXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZVByb2Nlc3MgPSBudWxsO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlx1RDgzRFx1REVEMSBTZXJ2ZXIgRHJhdy5pbyBpcyBzdG9wcGVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoRFJBV0lPX1ZJRVcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgbGF1bmNoRHJhd2lvU2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZVByb2Nlc3MpIHJldHVybjtcblxuICAgICAgICBjb25zdCB2YXVsdEJhc2VQYXRoID0gKHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgYW55KS5iYXNlUGF0aCBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHBsdWdpbkRpciA9IHBhdGguam9pbih2YXVsdEJhc2VQYXRoLCB0aGlzLm1hbmlmZXN0LmRpciEpO1xuICAgICAgICBjb25zdCB3ZWJBcHBQYXRoID0gcGF0aC5qb2luKHBsdWdpbkRpciwgXCJ3ZWJhcHBcIik7XG5cbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHdlYkFwcFBhdGgpKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiXHVEODNEXHVEQ0MyIGZvbGRlciAnd2ViYXBwJyBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXJ2ZVByb2Nlc3MgPSBzcGF3bihcIm5weFwiLCBbXCJzZXJ2ZVwiLCB3ZWJBcHBQYXRoLCBcIi1sXCIsIFwiODA4MFwiXSwge1xuICAgICAgICAgICAgY3dkOiBwbHVnaW5EaXIsXG4gICAgICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFjaGVkOiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICB9XG59XG5cbmNsYXNzIERyYXdJT1ZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG4gICAgcHJpdmF0ZSBwbHVnaW46IERyYXdJT1BsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHBsdWdpbjogRHJhd0lPUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRFJBV0lPX1ZJRVc7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheVRleHQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiRHJhdy5pb1wiO1xuICAgIH1cbiAgICBcbiAgICBnZXRJY29uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcInNoYXBlc1wiO1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBjb25zdCBpZnJhbWUgPSBjb250YWluZXIuY3JlYXRlRWwoXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgIHNyYzogXCJodHRwOi8vbG9jYWxob3N0OjgwODBcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IG5vbmU7XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxufVxuXG4gICAgYXN5bmMgb25DbG9z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
